#### Gough
```js
// import method

beforeEach(() => method()); // beforeAll()
afterEach(() => method()) // afterAll()


test('description', () => {
	expect(method(args)).toBe(result)
	// toBe - primitive
	// toEqual - object
	// toBeNull/ toBeFalsy/ toBeLessThan
	// toBeDefined - that thing exists
	// .not.toMatch() - regular expression match
	// array // toContain()
})

test('for async data, Promise Code', () => {
	expect.assertions(1);
	return method.then(data => {
		expect(data.name).toEqual(abc)
	})
})

test('for async-await', async() => {
	expect.assertions(1);
	const data = await method();
	expect(data.name).toEqual(abc)
})
```

```ts
describe('', () => {
	beforeEach(()=> method())

	// test1
	// test2
})
```
### NestJS
- Controller Unit test
```ts
describe('Controller Test', () => {
	beforeEach(async () => {
		const moduleRef = await Test.createTestingModule({
			imports: [],
			controllers: [ControllerName],
			providers: [AbcService]
		}).compile()
	})
})
```
2. create a `__mock__` folder in same level as `Service` class with a file same name as service class
```ts
export const ServiceName = jest.fn().mockReturnValue({
	method1: jest.fn().mockReturnValue(value) // mockResolvedValue
	
})
```
3.  create `test/stub` 
```ts
// method to get new stub object, so it is not shared (potentially mutated)
export const dataStub: Data = () => {
	return {}
}
```
4. add mock to `controller.spec` class
```ts
jest.mock(path_to_service_mock)

describe(.... {
	let controller: Controller, service: Service;
	beforeEach(....)
	controller = moduleRef.get<Controller>(Controller);
	service = moduleRef.get<Service>(Service);
	jest.clearAllMocks();

	describe('getAbc', () => {
		describe('when get is called', () => {
			let data: Data;
			beforeEach(async() => {
				id = await controller.getAbc(getStub()).id;
			});

		test('should call service', () => {
			expect(service.getAbc).toBeCalledWith(stub()).id)
		})
		
		test('should return appropriate', () => {
			expect(data).toEqual(stub())
		})
		
		})
	})
})
```
- Repository Unit test
```ts
describe('Repository Name', () => {
	// let repository/model;
	beforeEach(async () => {
		const moduleRef = await Test.createTestingModule({
			providers: [
				RepositoryName,
				{
					provide: getModelToken(Class.name)
					useClass; SupportClass
				}
			]
		})
	})
})
```
2. create `database/test/support` and create `mock.model.ts`
```ts
export abstract class MockModel<T> {
	protected abstract entityStub: T;

	constructor(createEntityData: T) {
		this.constructorSpy(createEntityData)
	}

	constructorSpy(_createEntityData: T) {}

	findOne(): { exec: () => T} {
		return {
			exec () : T => this.entityStub;
		}
	}
	async save() {
		return this.entityStub;
	}
}
```
- Integration Test
```ts

```



### Unit test



# Rest Backend
- user service
```ts
// Generated by CodiumAI

describe('UsersService', () => {

    // login with correct credentials returns a valid JWT token
    it('should return a valid JWT token when login with correct credentials', async () => {
      const usersRepository = {
        findOne: jest.fn().mockResolvedValue({
          id: '1',
          email: 'test@example.com',
          password: '$2a$10$somehashedpassword'
        })
      };
      const jwtService = {
        signAsync: jest.fn().mockResolvedValue('valid_jwt_token')
      };
      const configService = {
        get: jest.fn((key) => {
          if (key === 'JWT_EXPIRY') return '1d';
          if (key === 'JWT_SECRET') return 'secret';
        })
      };
      const usersService = new UsersService(usersRepository, jwtService, configService);
      const loginDto = { email: 'test@example.com', password: 'password123' };
      const result = await usersService.login(loginDto);
      expect(result.token).toEqual('valid_jwt_token');
      expect(jwtService.signAsync).toHaveBeenCalledWith({
        sub: '1',
        email: 'test@example.com'
      }, {
        expiresIn: '1d',
        secret: 'secret'
      });
    });

    // login with incorrect email throws BadRequestException
    it('should throw BadRequestException when login with incorrect email', async () => {
      const usersRepository = {
        findOne: jest.fn().mockResolvedValue(null)
      };
      const jwtService = jest.mock();
      const configService = jest.mock();
      const usersService = new UsersService(usersRepository, jwtService, configService);
      const loginDto = { email: 'wrong@example.com', password: 'password123' };
      await expect(usersService.login(loginDto)).rejects.toThrow(BadRequestException);
    });

    // register with valid data persists a new user with hashed password
    it('should persist a new user with hashed password when registering with valid data', async () => {
      const usersRepository = {
        create: jest.fn().mockResolvedValue({
          id: '1',
          email: 'test@example.com',
          password: '$2a$10$somehashedpassword'
        }),
        persistAndFlush: jest.fn()
      };
      const entityManager = {
        persistAndFlush: jest.fn()
      };
      const argon = {
        hash: jest.fn().mockResolvedValue('$2a$10$somehashedpassword')
      };
      const usersService = new UsersService(usersRepository, {}, {});
      usersService['_hashPassword'] = argon.hash;
      usersService['em'] = entityManager;
      const registerDto = {
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        phone: '1234567890'
      };
      await usersService.register(registerDto);
      expect(usersRepository.create).toHaveBeenCalledWith({
        email: 'test@example.com',
        password: '$2a$10$somehashedpassword',
        firstName: 'John',
        phone: '1234567890'
      });
      expect(entityManager.persistAndFlush).toHaveBeenCalled();
    });

    // getAllUser retrieves all users from the repository
    it('should return all users when getAllUser is called', async () => {
      const usersRepository = {
        findAll: jest.fn().mockResolvedValue([
          { id: '1', email: 'test1@example.com' },
          { id: '2', email: 'test2@example.com' }
        ])
      };
      const jwtService = {
        signAsync: jest.fn().mockResolvedValue('valid_jwt_token')
      };
      const configService = {
        get: jest.fn((key) => {
          if (key === 'JWT_EXPIRY') return '1d';
          if (key === 'JWT_SECRET') return 'secret';
        })
      };
      const usersService = new UsersService(usersRepository, jwtService, configService);
      const result = await usersService.getAllUser();
      expect(result).toEqual([
        { id: '1', email: 'test1@example.com' },
        { id: '2', email: 'test2@example.com' }
      ]);
      expect(usersRepository.findAll).toHaveBeenCalled();
    });

    // login with incorrect password throws BadRequestException
    it('should throw BadRequestException when login with incorrect password', async () => {
      const usersRepository = {
        findOne: jest.fn().mockResolvedValue({
          id: '1',
          email: 'test@example.com',
          password: '$2a$10$somehashedpassword'
        })
      };
      const usersService = new UsersService(usersRepository, {} as any, {} as any);
      const loginDto = { email: 'test@example.com', password: 'incorrectpassword' };
      await expect(usersService.login(loginDto)).rejects.toThrow(BadRequestException);
    });

    // register with invalid input data throws BadRequestException
    it('should throw BadRequestException when registering with invalid input data', async () => {
      const usersRepository = {
        create: jest.fn().mockRejectedValue(new BadRequestException('Invalid Input'))
      };
      const jwtService = {};
      const configService = {};
      const usersService = new UsersService(usersRepository, jwtService, configService);
      const registerDto = { email: 'test@example.com', password: 'password123' };
  
      await expect(usersService.register(registerDto)).rejects.toThrow(BadRequestException);
    });

    // register with existing email throws BadRequestException
    it('should throw BadRequestException when registering with existing email', async () => {
      const usersRepository = {
        findOne: jest.fn().mockResolvedValue({
          id: '1',
          email: 'existing@example.com',
          password: '$2a$10$somehashedpassword'
        }),
        create: jest.fn().mockResolvedValue({})
      };
      const configService = {
        get: jest.fn((key) => {
          if (key === 'JWT_EXPIRY') return '1d';
          if (key === 'JWT_SECRET') return 'secret';
        })
      };
      const usersService = new UsersService(usersRepository, {}, configService);
      const registerDto = {
        email: 'existing@example.com',
        password: 'password123',
        firstName: 'John',
        phone: '1234567890'
      };
      try {
        await usersService.register(registerDto);
      } catch (error) {
        expect(error).toBeInstanceOf(BadRequestException);
      }
    });

    // JWT token contains correct user id and email
    it('should return a valid JWT token with correct user id and email when login with correct credentials', async () => {
      const usersRepository = {
        findOne: jest.fn().mockResolvedValue({
          id: '1',
          email: 'test@example.com',
          password: '$2a$10$somehashedpassword'
        })
      };
      const jwtService = {
        signAsync: jest.fn().mockResolvedValue('valid_jwt_token')
      };
      const configService = {
        get: jest.fn((key) => {
          if (key === 'JWT_EXPIRY') return '1d';
          if (key === 'JWT_SECRET') return 'secret';
        })
      };
      const usersService = new UsersService(usersRepository, jwtService, configService);
      const loginDto = { email: 'test@example.com', password: 'password123' };
      const result = await usersService.login(loginDto);
      expect(result.token).toEqual('valid_jwt_token');
      expect(jwtService.signAsync).toHaveBeenCalledWith({
        sub: '1',
        email: 'test@example.com'
      }, {
        expiresIn: '1d',
        secret: 'secret'
      });
    });

    // password verification matches correctly with hashed password
    it('should verify password correctly when matching with hashed password', async () => {
      const usersRepository = {
        findOne: jest.fn().mockResolvedValue({
          id: '1',
          email: 'test@example.com',
          password: '$2a$10$somehashedpassword'
        })
      };
      const usersService = new UsersService(usersRepository, {} as any, {} as any);
      const result = await usersService.login({ email: 'test@example.com', password: 'password123' });
      expect(result).toBeDefined();
    });

    // register with missing optional fields successfully creates user
    it('should create user successfully with missing optional fields', async () => {
      const usersRepository = {
        create: jest.fn().mockResolvedValue({
          id: '1',
          email: 'test@example.com',
          password: '$2a$10$somehashedpassword'
        }),
        persistAndFlush: jest.fn()
      };
      const usersService = new UsersService(usersRepository, {}, {});
      const registerDto = { email: 'test@example.com', password: 'password123', firstName: 'John', phone: '1234567890' };
      await usersService.register(registerDto);
      expect(usersRepository.create).toHaveBeenCalledWith({
        email: 'test@example.com',
        password: expect.any(String),
        firstName: 'John',
        phone: '1234567890'
      });
      expect(usersRepository.persistAndFlush).toHaveBeenCalled();
    });

    // JWT token expiry is set correctly according to configuration
    it('should set JWT token expiry correctly according to configuration', async () => {
      const jwtService = {
        signAsync: jest.fn().mockResolvedValue('valid_jwt_token')
      };
      const configService = {
        get: jest.fn((key) => {
          if (key === 'JWT_EXPIRY') return '1d';
          if (key === 'JWT_SECRET') return 'secret';
        })
      };
      const usersService = new UsersService({}, jwtService, configService);
      const result = await usersService._signToken('1', 'test@example.com');
      expect(result.token).toEqual('valid_jwt_token');
      expect(jwtService.signAsync).toHaveBeenCalledWith({
        sub: '1',
        email: 'test@example.com'
      }, {
        expiresIn: '1d',
        secret: 'secret'
      });
    });

    // password hashing uses argon2
    it('should hash password using argon2', async () => {
      const password = 'password123';
      const hashedPassword = '$2a$10$somehashedpassword';
      jest.spyOn(argon, 'hash').mockResolvedValue(hashedPassword);
      const usersService = new UsersService({}, {}, {});
      const result = await usersService._hashPassword(password);
      expect(result).toEqual(hashedPassword);
    });
});

```
